/*-
 * #%L
 * A Fiji plugin for integrating large language models.
 * %%
 * Copyright (C) 2025 ImageJ Developers
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.html>.
 * #L%
 */

package sc.fiji.llm.macro;

import java.util.List;

import javax.swing.SwingUtilities;

import org.scijava.plugin.Parameter;
import org.scijava.plugin.Plugin;

import dev.langchain4j.agent.tool.P;
import dev.langchain4j.agent.tool.Tool;
import net.imagej.legacy.LegacyService;
import sc.fiji.llm.tools.AbstractAiToolPlugin;
import sc.fiji.llm.tools.AiToolPlugin;
import sc.fiji.llm.tools.ToolContext;

/**
 * AI tool that provides macro recording capabilities for the LLM. Allows the
 * assistant to open the macro recorder and capture user actions.
 */
@Plugin(type = AiToolPlugin.class)
public class ImageJMacroTool extends AbstractAiToolPlugin {

	@Parameter
	private LegacyService legacyService;

	public ImageJMacroTool() {
		super(ImageJMacroTool.class);
	}

	@Override
	public String getToolContext() {
		return ToolContext.MACRO;
	}

	@Override
	public String getName() {
		return "Macro Writing Tools";
	}

	@Override
	public String getUsage() {
		return "We use ImageJ Macros to build reproducible workflows. These tools support macro creation and editing.\n" +
			"BEFORE using any other Macro Writing tool, use macroGuide if it's not in your context.\n" +
			"To start recording a macro, use startRecorder.\n" +
			"To find macro functions, use: 1) listMacroCategories(), 2) listMacroFunctionsByCategory(category).";
	}

	@Tool(value = { "Returns: A list of ImageJ macro function category names" })
	public String listMacroCategories() {
		List<String> categories = MacroFunctionRegistry.getCategories();
		if (categories.isEmpty()) {
			return "No categories found";
		}
		StringBuilder sb = new StringBuilder();
		sb.append("Available macro function categories:\n\n");
		for (String category : categories) {
			sb.append("• ").append(category).append("\n");
		}
		return sb.toString();
	}

	@Tool(value = {
		"Args: category - the category name (from listMacroCategories)",
		"Returns: Information on all ImageJ macro functions in the given category" })
	public String listMacroFunctionsByCategory(@P("category") String category) {
		if (category == null || category.trim().isEmpty()) {
			return "ERROR: Category cannot be empty";
		}

		List<MacroFunctionRegistry.MacroFunction> functions = MacroFunctionRegistry
			.getByCategory(category);

		if (functions.isEmpty()) {
			return "No functions found in category: " + category;
		}

		StringBuilder sb = new StringBuilder();

		for (MacroFunctionRegistry.MacroFunction func : functions) {
			sb.append("• **").append(func.simpleString()).append("**\n");
		}

		return sb.toString();
	}

	@Tool(value = { "Start the macro recorder", })
	public String startRecorder() {
		try {
			// Run the macro recorder command through ImageJ
			// The Recorder class will automatically handle bringing the existing
			// instance to front if it's already open (see ij.plugin.frame.Recorder
			// constructor)
			if (SwingUtilities.isEventDispatchThread()) {
				legacyService.runLegacyCommand("ij.plugin.frame.Recorder", "");
			}
			else {
				SwingUtilities.invokeLater(() -> {
					legacyService.runLegacyCommand("ij.plugin.frame.Recorder", "");
				});
			}
			return "Macro recorder is now active.";
		}
		catch (RuntimeException e) {
			return "ERROR: Failed to open macro recorder: " + e.getMessage();
		}
	}

	@Tool(value = { "Returns: A detailed ImageJ Macro guide for YOU, the LLM" })
	public String macroGuide() {
		return """
				ImageJ Macro Guide
				==================
				WORKFLOW: Macros are generated by recording menu commands in the macro recorder, then edited in the script editor.

				SYNTAX
				------
				Java-like with dynamic types: v = 1.23; v = "hi";
				Control flow: if/else, for, while, do/while
				Functions: function name() { ... }; name(); // user functions need ()
				Built-ins: title = getTitle() // () optional
				Commands: run("Menu Command", "params"); // params from recorder

				ACTIVE IMAGE
				------------
				Methods operate on active image.
				Control via: getImageID() and selectImage(id), or getTitle() and selectWindow(title)
				Common pattern: run("Duplicate...", " "), process copy, re-select original

				RECORDING WORKFLOW
				------------------
				1. Start recorder (startRecorder tool)
				2. User sets "Record" language (affects syntax)
				3. Run commands via UI/search/tools - recorder captures syntax
				4. User clicks "Create" to generate script
				5. LLM cleans up script (remove spurious commands like "close")

				NOTE: Generated scripts lack @Parameters and imports for non-macro languages.
				        """;
	}
}
